
is_osx() {
	echo $OSTYPE | grep -q 'darwin'
}

# mkdir and cd to it
mcd() {
	[[ -z "$1" ]] && { echo "Usage: $0 DIRNAME" >&2; return 1; }
	mkdir -p "$1" && cd "$1"
}

# Display a man page in Preview
pman() {
	[[ -z "$1" ]] && { echo "Usage: $0 MANPAGE" >&2; return 1; }
	man -t "${1}" | open -f -a /Applications/Preview.app
}

# Simple history find
hf() {
  grep "$@" ~/.bash_history
}

expand_path() {
	local relpath=$1
	[[ -z "$relpath" ]] && relpath=$(pwd)
	ruby -e "puts File.expand_path('$relpath')"
}

canonical_path() {
	local the_path=$(expand_path $1)
	echo $(cd $(dirname $the_path); pwd -P)/$(basename $the_path)
}

d() {
	local ds="$(dirs -v)"
	if [[ $# -eq 0 ]]; then
		echo $ds
	else
		# Get directory with the given number in the stack
		echo $ds | grep "^${1}[[:space:]]" | awk '{print $2}'
	fi
}

# search the directory frontmost in the Finder
#posfind() { find "$(posd)" -name "*$1*"; }

# grep the directory frontmost in the Finder
#posgrep() { grep -iIrn "$1" "$(posd)"; }

##### Project stuff

find_projects() {
	for d in $(echo $PROJECT_DIRS | tr : "\n"); do
		find $d -type d -mindepth 1 -maxdepth 1
	done
}

resolve_project() {
	for project in $(find_projects); do
		[[ "$(basename $project)" = "$1" ]] && { echo $project; return 0; }
	done

	return 1
}

is_project_dir() {
	local dir=$1
	[[ -z "$dir" ]] && dir=$(pwd)
	[[ ! -d $dir ]] && return 1

	# .git directory means it's a project
	[[ -d "$(echo $dir | sed -e 's/\/$//')/.git" ]] && return 0

	# Being in one of our project directories means it's a project
	dir=$(canonical_path $dir)
	local parent_dir=$(dirname $dir)
	for d in $(echo $PROJECT_DIRS | tr : "\n"); do
		[[ "$(canonical_path $d)" == "$parent_dir" ]] && return 0
	done

	return 1
}

find_parent_project_dir() {
	local dir=$1
	[[ -z "$dir" ]] && dir=$(pwd)
	[[ ! -d $dir ]] && return 1

	while [[ "$dir" != "/" ]] && [[ -n "$dir" ]]; do
		is_project_dir $dir && { echo $dir; return 0; }
		dir=$(dirname $dir)
	done
	return 1
}

# Find my projects
p() {
	if [[ "$1" = "-h" ]]; then
		echo "Usage: p PROJECTNAME"
	elif [[ $# -eq 0 ]]; then
		local project_dir=$(find_parent_project_dir)
		if [[ -n "$project_dir" ]]; then
			cd $project_dir
		else
			echo "Not in a project directory!" >&2
			return 1
		fi
	else
		local project=$(resolve_project $1)
		if [[ -n "$project" ]]; then
			cd $project
		else
			echo "Could not find project: $1" >&2
			return 1
		fi
	fi
}

##### Shell and dotfile management functions

reload_shell() {
	local rc_file=~/.zshrc
	[[ -z "$ZSH_VERSION" ]] && rc_file=~/.bashrc
	echo -n "Sourcing ${rc_file}... "
	source $rc_file
	echo "Done."
}

# Make symlink dotfiles in HOME to the regular files in Dropbox.
# Just defer to the script that does it - it is standalone to allow
# linking without sourcing this function first.
link_dotfiles() {
	local dropbox_dir=$HOME/Dropbox
	if [ -d $dropbox_dir ]; then
		local link_script=$dropbox_dir/dotfiles/link_dotfiles
		if [ -f $link_script ]; then
			ruby $link_script
		else
			echo "$link_script does not exist or is not a regular file"
			return 1
		fi
	else
		echo "$dropbox_dir does not exist or is not a directory - is Dropbox set up?"
		return 1
	fi
}

dotfiles_project() {
	mate $HOME/Dropbox/dotfiles
}

is_ssh_shell() {
	[[ "$SESSION_TYPE" = 'remote/ssh' ]]
}

if is_osx; then
	osx_setup() {
		~/.osx.d/osx_setup
	}
fi
